<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Visualizer</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden; /* Disable scrollbars */
        height: 100%; /* Full height */
        width: 100%; /* Full width */
    }
    #mynetwork {
        height: 100%;
        width: 100%;
        position: absolute; /* Positioned relative to the viewport */
        top: 0;
        left: 0;
    }
.search-results-popup {
    display: none;
    position: absolute;
    top: 50px;
    right: 10px;
    border: 1px solid #ccc;
    background: #fff;
    z-index: 10;
    padding: 10px;
    max-height: 300px;
    overflow-y: auto;
    width: 200px;
}
</style>
</head>
<body>

<script>
// Define a global variable to hold the raw JSON data
var rawJsonData = {}; // Replace with actual JSON data if needed
</script>
<script>
// Load JSON data from local storage if available
document.addEventListener('DOMContentLoaded', function() {
    // Check if rawJsonData is not empty
    if (Object.keys(rawJsonData).length !== 0) {
        processJsonData(rawJsonData);
        visualizeTree();
    } else {
        var storedJson = localStorage.getItem('treeData');
        if (storedJson) {
            var json = JSON.parse(storedJson);
            processJsonData(json);
            visualizeTree();
        }
    }
});
</script>
<div style="position: absolute; top: 10px; right: 10px; z-index: 5;">
    <button id="clearButton">Clear</button>
<input type="text" id="searchInput" placeholder="Search nodes...">
<button id="searchButton">Search</button>
</div>
<div id="searchResultsPopup" class="search-results-popup"></div>
<div id="mynetwork"></div>

<script>
// Create a network
var container = document.getElementById("mynetwork");
var data = {
  nodes: new vis.DataSet([]),
  edges: new vis.DataSet([]),
};
var options = {
  layout: {
    hierarchical: {
      direction: "LR", // Left to Right
      sortMethod: "directed", // Directed layout to respect the direction of edges
      levelSeparation: 50,
      nodeSpacing: 30,
    },
  },
  physics: {
    enabled: false, // Disable physics for hierarchical layout
  },
};
var network = new vis.Network(container, data, options);
// Store the full tree data globally
var fullTreeData = { nodes: [], edges: [] };
// Keep track of the current search result index
var currentSearchResultIndex = 0;
// Function to process JSON and store it in fullTreeData
function processJsonData(json) {
    var nodes = [];
    var edges = [];
    for (var key in json) {
        if (json.hasOwnProperty(key)) {
            var node = json[key];
            var numericKey = Number(key);
            nodes.push({ id: numericKey, label: node.word, shape: "box", probability: node.prob });

            if (node.parent !== null) {
                edges.push({ from: Number(node.parent), to: numericKey });
            }
        }
    }
    fullTreeData = { nodes: nodes, edges: edges };
}
    console.log("JSON data processed", fullTreeData);

function getDescendants(nodeId, edges) {
    var descendants = [];
    var stack = [nodeId];
    console.log(edges)
    while (stack.length > 0) {
        console.log("Stack: " + stack);
        var currentId = Number(stack.pop());
        descendants.push(currentId);
        edges.forEach(function (edge) {
            if (edge.from === currentId && !descendants.includes(edge.to)) {
                stack.push(edge.to);
            }
        });
    }
    console.log("Descendants: " + descendants);
    return descendants;
}

// Update the visualizeTree function to optionally filter for a subtree and scale edge widths
function visualizeTree(subtreeRootId) {
  var nodes = fullTreeData.nodes;
  var edges = fullTreeData.edges;

  // If a subtreeRootId is provided, filter nodes and edges to only those in the subtree
  if (subtreeRootId) {
    var descendants = getDescendants(subtreeRootId, edges);
    console.log("Filtering for subtree with root ID: " + subtreeRootId, edges);
    nodes = nodes.filter((node) => descendants.includes(Number(node.id)));
    edges = edges.filter(
      (edge) =>
        descendants.includes(edge.to) || descendants.includes(edge.from),
    );
    console.log("Filtered nodes: ", nodes, "Filtered edges: ", edges);
  }

  // Calculate min and max weights for scaling after filtering
  var min_weight = Number.POSITIVE_INFINITY;
  var max_weight = 0;

  nodes.forEach(function (node) {
    if (node.probability < min_weight) {
      min_weight = node.probability;
    }
    if (node.probability > max_weight) {
      max_weight = node.probability;
    }
  });

  // Scale edge widths based on node probabilities
  edges = edges.map(function (edge) {
    return {
      from: edge.from,
      to: edge.to,
      value: scale_edge_width(
        nodes.find((node) => node.id === edge.to).probability,
        max_weight,
        min_weight,
        10 // Log base
      ),
    };
  });

  // Update vis.js data
  data.nodes.clear();
  data.edges.clear();
  data.nodes.add(nodes);
  data.edges.add(edges);

  // If a subtreeRootId is provided, recenter the view on the subtree
  if (subtreeRootId) {
    var subtreeRoot = nodes.find((node) => node.id === subtreeRootId);
    network.focus(subtreeRootId, { scale: 1 });
  }

}

// Function to reset the color of all nodes
function resetNodeColors() {
    fullTreeData.nodes.forEach(function(node) {
        node.color = undefined; // Reset to default color
    });
}

// Function to highlight nodes by changing their color
function highlightNodes(nodeIds) {
    resetNodeColors(); // Reset all nodes before highlighting new ones
    fullTreeData.nodes.forEach(function(node) {
        if (nodeIds.includes(node.id)) {
            node.color = { background: 'yellow', border: 'orange' }; // Highlight color
        }
    });
    visualizeTree(); // Re-render the tree with highlighted nodes
}
// Event listener for click events to display subtrees
network.on("click", function (params) {
  if (params.nodes.length === 1) {
    var nodeId = params.nodes[0];
    console.log("Node clicked: " + nodeId);
    var nodeId = params.nodes[0];
    visualizeTree(nodeId);
  }
});

// Event listener for right-click events to return to the full tree
network.on("oncontext", function (params) {
  params.event.preventDefault();
  console.log("Right-click detected. Returning to full tree view.");
  visualizeTree(); // Pass the full tree data to restore the full view
});

// Event listener for dragover to allow for the drop action
document.body.addEventListener("dragover", function (e) {
  e.preventDefault();
});

// Event listener for drop to handle the file data
document.body.addEventListener("drop", function (e) {
  e.preventDefault();
  var files = e.dataTransfer.files;
  if (files.length > 0) {
    var file = files[0];
    var reader = new FileReader();
    reader.onload = function () {
      var json = JSON.parse(reader.result);
    console.log("File dropped, processing JSON data...");
      processJsonData(json); // Process the JSON data
    console.log("Visualizing tree...");
      visualizeTree(); // Visualize the full tree
localStorage.setItem('treeData', JSON.stringify(json));
    };
    reader.readAsText(file);
  }
});

// Define the scale_edge_width function in JavaScript
function scale_edge_width(
  cumulative_weight,
  max_weight,
  min_weight,
  log_base,
  max_thickness = 33,
  min_thickness = 1,
) {
  // Ensure the cumulative_weight is not less than min_weight to avoid log(0)
  cumulative_weight = Math.max(cumulative_weight, min_weight);

  // Apply logarithmic scaling
  var log_weight =
    Math.log(cumulative_weight) / Math.log(log_base) -
    Math.log(min_weight) / Math.log(log_base);
  var log_max =
    Math.log(max_weight) / Math.log(log_base) -
    Math.log(min_weight) / Math.log(log_base);

  // Amplify the difference after logarithmic scaling
  var amplified_weight = Math.pow(log_weight / log_max, 2.5); // Raising to a power to amplify differences

  // Scale the amplified_weight to the range of thicknesses
  var scaled_weight =
    amplified_weight * (max_thickness - min_thickness) + min_thickness;

  return scaled_weight;
}
// Simple fuzzy search function to match node labels
// Enhanced fuzzy search function to match node labels and count descendants
function fuzzySearch(query, nodes, edges) {
    var results = [];
    var queryLower = query.toLowerCase();
    nodes.forEach(function(node) {
        if (node.label.toLowerCase().includes(queryLower)) {
            var descendantsCount = getDescendants(node.id, edges).length - 1; // Exclude the node itself
            results.push({ node: node, count: descendantsCount });
        }
    });
    return results;

}
// Event listener for the search input to perform live search and highlight all results
// Debounce function to limit the rate at which a function can fire
function debounce(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this, args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};

// Cache for storing descendants of nodes
var descendantsCache = {};

// Event listener for the search input to perform live search and highlight all results
document.getElementById('searchInput').addEventListener('input', debounce(function() {
    var query = document.getElementById('searchInput').value;
    var searchResultsPopup = document.getElementById('searchResultsPopup');
    if (query) {
        var searchResults = fuzzySearch(query, fullTreeData.nodes, fullTreeData.edges);
        if (searchResults.length > 0) {
            var fragment = document.createDocumentFragment();
            searchResults.forEach(function(result) {
                var div = document.createElement('div');
                div.className = 'search-result-item';
                div.setAttribute('data-node-id', result.node.id);
                div.textContent = result.node.label + ' (' + result.count + ' matches)';
                fragment.appendChild(div);
            });
            searchResultsPopup.innerHTML = '';
            searchResultsPopup.appendChild(fragment);
            searchResultsPopup.style.display = 'block';
            // Highlight all matching nodes
            var matchingNodeIds = searchResults.map(function(result) { return result.node.id; });
            highlightNodes(matchingNodeIds);
            console.log("Search results: ", searchResults);
        } else {
            searchResultsPopup.innerHTML = 'No matching nodes found.';
            resetNodeColors(); // Reset node colors if no matches found
            visualizeTree(); // Re-render the tree
            console.log("No matching nodes found.");
        }
    } else {
        searchResultsPopup.style.display = 'none';
        resetNodeColors(); // Reset node colors when search is cleared
        visualizeTree(); // Re-render the tree
    }
}, 250)); // Debounce rate of 250 milliseconds

// Event listener for clicking on search result items
document.addEventListener('click', function(event) {
    if (event.target.classList.contains('search-result-item')) {
        var nodeId = event.target.getAttribute('data-node-id');
        network.focus(nodeId, { scale: 1 });
        document.getElementById('searchResultsPopup').style.display = 'none';
    }
});
// Event listener for the search input to handle Enter keypress and cycle through matches
document.getElementById('searchInput').addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
        var searchResultsPopup = document.getElementById('searchResultsPopup');
        var searchResultItems = searchResultsPopup.getElementsByClassName('search-result-item');
        if (searchResultItems.length > 0) {
            // If we've reached the end of the list, start from the beginning
            if (currentSearchResultIndex >= searchResultItems.length) {
                currentSearchResultIndex = 0;
            }
            var resultItem = searchResultItems[currentSearchResultIndex];
            var nodeId = resultItem.getAttribute('data-node-id');
            network.focus(nodeId, { scale: 1 });
            currentSearchResultIndex++; // Move to the next result for the next Enter press
        }
    }
});

// Event listener for the 'Clear' button
document.getElementById('clearButton').addEventListener('click', function() {
    localStorage.removeItem('treeData'); // Clear local storage
    location.reload(); // Reload the page to reset the visualization
});
</script>
</body>
</html>
