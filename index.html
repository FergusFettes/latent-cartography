<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Visualizer</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden; /* Disable scrollbars */
        height: 100%; /* Full height */
        width: 100%; /* Full width */
    }
    #mynetwork {
        height: 100%;
        width: 100%;
        position: absolute; /* Positioned relative to the viewport */
        top: 0;
        left: 0;
    }
#infoBox {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background: #fff;
    z-index: 10;
}
.search-results-popup {
    display: none;
    position: absolute;
    top: 50px;
    right: 10px;
    border: 1px solid #ccc;
    background: #fff;
    z-index: 10;
    padding: 10px;
    max-height: 300px;
    overflow-y: auto;
    width: 200px;
}
</style>
</head>
<body>

<script>
// Define a global variable to hold the raw JSON data
var rawJsonData = {}; // Replace with actual JSON data if needed
</script>
<script>
// Load JSON data from local storage if available
document.addEventListener('DOMContentLoaded', function() {
    // Check if rawJsonData is not empty
    if (Object.keys(rawJsonData).length !== 0) {
        processJsonData(rawJsonData);
        visualizeTree();
    } else {
        var storedJson = localStorage.getItem('treeData');
        if (storedJson) {
            var json = JSON.parse(storedJson);
            processJsonData(json);
            visualizeTree();
        }
    }
});
</script>
<div style="position: absolute; top: 10px; right: 10px; z-index: 5;">
    <button id="clearButton">Clear</button>
<select id="datasetDropdown">
    <option value="">Select a dataset</option>
    <option value="fergusfettes/gpt2_noken_1e-06_AtypicaldefinitionofXwouldbe">GPT-2 Centroid</option>
</select>
<input type="text" id="searchInput" placeholder="Search nodes...">
<button id="searchButton">Search</button>
</div>
<div id="searchResultsPopup" class="search-results-popup"></div>
<div id="infoBox">
    <p>Total Nodes: <span id="totalNodes">0</span></p>
</div>
<div id="mynetwork"></div>

<script>
// Create a network
var container = document.getElementById("mynetwork");
var data = {
  nodes: new vis.DataSet([]),
  edges: new vis.DataSet([]),
};
var options = {
  layout: {
    hierarchical: {
      direction: "LR", // Left to Right
      sortMethod: "directed", // Directed layout to respect the direction of edges
      levelSeparation: 50,
      nodeSpacing: 30,
    },
  },
  physics: {
    enabled: false, // Disable physics for hierarchical layout
  }
};
var network = new vis.Network(container, data, options);
// Store the full tree data globally
var fullTreeData = { nodes: [], edges: [] };
// Flag to indicate if the tree data has changed and needs re-rendering
var treeDataChanged = true;
// Var to keep track of highlited node ids
var highlightedNodeIds = [];
// Keep track of the current search result index
var currentSearchResultIndex = 0;
// Function to process JSON and store it in fullTreeData
function processJsonData(json) {
  var nodes = [];
  var edges = [];
  for (var key in json) {
    if (json.hasOwnProperty(key)) {
      var node = json[key];
      var numericKey = Number(key);
      nodes.push({
        id: numericKey,
        label: node.word,
        shape: "box",
        color: {
          background: "white",
          border: "#135061",
          // border: "white"
        },
        borderWidth: 1,
        probability: node.prob,
      });

      if (node.parent !== null) {
        edges.push({ from: Number(node.parent), to: numericKey});
      }
    }
  }
  fullTreeData = { nodes: nodes, edges: edges };
  // Set the flag to true as the tree data has been updated
  treeDataChanged = true;
}

// Memoization cache for getDescendants function
var descendantsCache = {};

function getDescendants(nodeId, edges) {
  // Check if result is already cached
  if (descendantsCache[nodeId]) {
    return descendantsCache[nodeId];
  }

  var descendants = new Set([nodeId]);
  var stack = [nodeId];

  // Convert edges to adjacency list for faster lookups
  var adjacencyList = edges.reduce(function (acc, edge) {
    if (!acc[edge.from]) {
      acc[edge.from] = [];
    }
    acc[edge.from].push(edge.to);
    return acc;
  }, {});

  while (stack.length > 0) {
    var currentId = stack.pop();
    var children = adjacencyList[currentId] || [];
    for (var i = 0; i < children.length; i++) {
      var childId = children[i];
      if (!descendants.has(childId)) {
        descendants.add(childId);
        stack.push(childId);
      }
    }
  }

  // Convert Set to Array for the result
  var descendantsArray = Array.from(descendants);
  // Cache the result before returning
  descendantsCache[nodeId] = descendantsArray;
  return descendantsArray;
}

// Update the visualizeTree function to optionally filter for a subtree and scale edge widths
function visualizeTree(subtreeRootId) {
  // Only re-render if the tree data has changed
  if (!treeDataChanged) {
    return;
  }

  var nodes = fullTreeData.nodes;
  var edges = fullTreeData.edges;

  // If a subtreeRootId is provided, filter nodes and edges to only those in the subtree
  if (subtreeRootId) {
    var descendants = getDescendants(subtreeRootId, edges);
    nodes = nodes.filter((node) => descendants.includes(Number(node.id)));
    edges = edges.filter(
      (edge) =>
        descendants.includes(edge.to) || descendants.includes(edge.from),
    );
  }

  // Calculate min and max weights for scaling after filtering
  var min_weight = Number.POSITIVE_INFINITY;
  var max_weight = 0;

  nodes.forEach(function (node) {
    if (node.probability < min_weight) {
      min_weight = node.probability;
    }
    if (node.probability > max_weight) {
      max_weight = node.probability;
    }
  });

  // Scale edge widths based on node probabilities
  edges = edges.map(function (edge) {
    return {
      from: edge.from,
      to: edge.to,
      value: scale_edge_width(
        nodes.find((node) => node.id === edge.to).probability,
        max_weight,
        min_weight,
        10, // Log base
      ),
    };
  });

  // Update vis.js data
  data.nodes.clear();
  data.edges.clear();
  data.nodes.add(nodes);
  data.edges.add(edges);

  // If a subtreeRootId is provided, recenter the view on the subtree
  if (subtreeRootId) {
    var subtreeRoot = nodes.find((node) => node.id === subtreeRootId);
    network.focus(subtreeRootId, { scale: 1 });
  }

  // Reset the flag as the tree has been rendered
  treeDataChanged = false;
}

// Function to update the info box with total nodes and FPS
function updateInfoBox() {
  var totalNodes = data.nodes.length;
  document.getElementById("totalNodes").textContent = totalNodes;
}

// Call updateInfoBox when visualizing the tree
updateInfoBox();

// Update the info box every second
setInterval(updateInfoBox, 1000);

// Function to reset the color of all nodes
// Function to update the color of nodes directly in the network
function updateNodeColors(nodeIds, color) {
  nodeIds.forEach(function (nodeId) {
    var nodeToUpdate = network.body.data.nodes.get(nodeId);
    if (nodeToUpdate) {
      network.body.data.nodes.update({ id: nodeId, color: color });
    }
  });
}

// Function to highlight nodes by changing their color
function highlightNodes(nodeIds) {
  // First reset all nodes to their default color
  updateNodeColors(highlightedNodeIds, undefined);
  // Then apply the highlight color to the search result nodes
  updateNodeColors(nodeIds, { background: "yellow", border: "orange" });
  // Store the current highlighted node ids
  highlightedNodeIds = nodeIds;
}

// Event listener for click events to display subtrees
network.on("click", function (params) {
  if (params.nodes.length === 1) {
    var nodeId = params.nodes[0];
    var nodeId = params.nodes[0];
    treeDataChanged = true;
    visualizeTree(nodeId);
  }
});

// Event listener for right-click events to return to the full tree
network.on("oncontext", function (params) {
  params.event.preventDefault();
  treeDataChanged = true;
  visualizeTree(); // Pass the full tree data to restore the full view
});

// Event listener for dragover to allow for the drop action
document.body.addEventListener("dragover", function (e) {
  e.preventDefault();
});

// Event listener for drop to handle the file data
document.body.addEventListener("drop", function (e) {
  e.preventDefault();
  var files = e.dataTransfer.files;
  if (files.length > 0) {
    var file = files[0];
    var reader = new FileReader();
    reader.onload = function () {
      var json = JSON.parse(reader.result);
      processJsonData(json); // Process the JSON data
      visualizeTree(); // Visualize the full tree
      // Set the flag to true as the tree data has been updated
      treeDataChanged = true;
      localStorage.setItem("treeData", JSON.stringify(json));
    };
    reader.readAsText(file);
  }
});

// Define the scale_edge_width function in JavaScript
function scale_edge_width(
  cumulative_weight,
  max_weight,
  min_weight,
  log_base,
  max_thickness = 15,
  min_thickness = 1,
) {
  // Ensure the cumulative_weight is not less than min_weight to avoid log(0)
  cumulative_weight = Math.max(cumulative_weight, min_weight);

  // Apply logarithmic scaling
  var log_weight =
    Math.log(cumulative_weight) / Math.log(log_base) -
    Math.log(min_weight) / Math.log(log_base);
  var log_max =
    Math.log(max_weight) / Math.log(log_base) -
    Math.log(min_weight) / Math.log(log_base);

  // Amplify the difference after logarithmic scaling
  var amplified_weight = Math.pow(log_weight / log_max, 2.5); // Raising to a power to amplify differences

  // Scale the amplified_weight to the range of thicknesses
  var scaled_weight =
    amplified_weight * (max_thickness - min_thickness) + min_thickness;

  return scaled_weight;
}
// Simple fuzzy search function to match node labels
// Enhanced fuzzy search function to match node labels and count descendants
// with caching to speed up repeated searches
function fuzzySearch(query, nodes, edges) {
  var results = [];
  var queryLower = query.toLowerCase();
  // Check if the search results are already cached
  if (searchCache[queryLower]) {
    return searchCache[queryLower];
  }
  nodes.forEach(function (node) {
    if (node.label.toLowerCase().includes(queryLower)) {
      var descendantsCount = getDescendants(node.id, edges).length - 1; // Exclude the node itself
      results.push({ node: node, count: descendantsCount });
    }
  });
  // Cache the search results
  searchCache[queryLower] = results;
  return results;
}
// Event listener for the search input to perform live search and highlight all results
// Debounce function to limit the rate at which a function can fire
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
      args = arguments;
    var later = function () {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}

// Cache for storing search results to avoid recalculating the same searches
var searchCache = {};

// Event listener for the search input to perform live search and highlight all results
document.getElementById("searchInput").addEventListener(
  "input",
  debounce(function () {
    var query = document.getElementById("searchInput").value;
    var searchResultsPopup = document.getElementById("searchResultsPopup");
    if (query) {
      var searchResults = fuzzySearch(
        query,
        fullTreeData.nodes,
        fullTreeData.edges,
      );
      if (searchResults.length > 0) {
        var fragment = document.createDocumentFragment();
        searchResults.forEach(function (result) {
          var div = document.createElement("div");
          div.className = "search-result-item";
          div.setAttribute("data-node-id", result.node.id);
          div.textContent =
            result.node.label + " (" + result.count + " matches)";
          fragment.appendChild(div);
        });
        searchResultsPopup.innerHTML = "";
        searchResultsPopup.appendChild(fragment);
        searchResultsPopup.style.display = "block";
        // Highlight all matching nodes
        var matchingNodeIds = searchResults.map(function (result) {
          return result.node.id;
        });
        highlightNodes(matchingNodeIds);
      } else {
        searchResultsPopup.innerHTML = "No matching nodes found.";
        highlightNodes([]); // Reset node colors if no matches found
        visualizeTree(); // Re-render the tree
      }
    } else {
      searchResultsPopup.style.display = "none";
      highlightNodes([]); // Reset node colors when search is cleared
      visualizeTree(); // Re-render the tree
    }
  }, 500),
); // Increase debounce rate to 500 milliseconds to reduce search frequency

// Event listener for clicking on search result items
document.addEventListener("click", function (event) {
  if (event.target.classList.contains("search-result-item")) {
    var nodeId = event.target.getAttribute("data-node-id");
    network.focus(nodeId, { scale: 1 });
    document.getElementById("searchResultsPopup").style.display = "none";
  }
});
// Event listener for the search input to handle Enter keypress and cycle through matches
document
  .getElementById("searchInput")
  .addEventListener("keypress", function (event) {
    if (event.key === "Enter") {
      var searchResultsPopup = document.getElementById("searchResultsPopup");
      var searchResultItems =
        searchResultsPopup.getElementsByClassName("search-result-item");
      if (searchResultItems.length > 0) {
        // If we've reached the end of the list, start from the beginning
        if (currentSearchResultIndex >= searchResultItems.length) {
          currentSearchResultIndex = 0;
        }
        var resultItem = searchResultItems[currentSearchResultIndex];
        var nodeId = resultItem.getAttribute("data-node-id");
        network.focus(nodeId, { scale: 1 });
        currentSearchResultIndex++; // Move to the next result for the next Enter press
      }
    }
  });

// Event listener for the 'Clear' button
document.getElementById("clearButton").addEventListener("click", function () {
  localStorage.removeItem("treeData"); // Clear local storage
  location.reload(); // Reload the page to reset the visualization
});

// Event listener for the dataset dropdown menu
document.getElementById("datasetDropdown").addEventListener("change", function (event) {
    var dataset = event.target.value;
    if (dataset) {
        fetchDatasetFromHuggingFace(dataset);
    }
});

// Function to fetch a dataset from Hugging Face and process it
function fetchDatasetFromHuggingFace(dataset) {
    var url = `https://huggingface.co/${dataset}/raw/main/test.json`;
    fetch(url)
        .then(response => response.json())
        .then(json => {
            processJsonData(json); // Process the JSON data
            visualizeTree(); // Visualize the full tree
            // Set the flag to true as the tree data has been updated
            treeDataChanged = true;
            localStorage.setItem("treeData", JSON.stringify(json));
        })
        .catch(error => {
            console.error("Error fetching dataset from Hugging Face:", error);
        });
}
</script>
</body>
</html>
