<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Visualizer</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden; /* Disable scrollbars */
        height: 100%; /* Full height */
        width: 100%; /* Full width */
    }
    #mynetwork {
        height: 100%;
        width: 100%;
        position: absolute; /* Positioned relative to the viewport */
        top: 0;
        left: 0;
    }
    #fileInput {
        position: absolute; /* Positioned relative to the viewport */
        top: 10px;
        left: 10px;
        z-index: 5; /* Above the visualization */
    }
</style>
    </style>
</head>
<body>

<div>
    <input type="file" id="fileInput" accept=".json">
</div>
<div id="mynetwork"></div>

<script>
// Create a network
var container = document.getElementById("mynetwork");
var data = {
  nodes: new vis.DataSet([]),
  edges: new vis.DataSet([]),
};
var options = {
  layout: {
    hierarchical: {
      direction: "LR", // Left to Right
      sortMethod: "directed", // Directed layout to respect the direction of edges
      levelSeparation: 50,
      nodeSpacing: 30,
    },
  },
  physics: {
    enabled: false, // Disable physics for hierarchical layout
  },
};
var network = new vis.Network(container, data, options);
// Store the full tree data globally
var fullTreeData = { nodes: [], edges: [] };
// Function to process JSON and store it in fullTreeData
function processJsonData(json) {
    var nodes = [];
    var edges = [];
    for (var key in json) {
        if (json.hasOwnProperty(key)) {
            var node = json[key];
            nodes.push({ id: key, label: node.word, shape: "box" });

            if (node.parent !== null) {
                edges.push({ from: node.parent, to: key });
            }
        }
    }
    fullTreeData = { nodes: nodes, edges: edges };
}
    console.log("JSON data processed", fullTreeData);

function getDescendants(nodeId, edges) {
    var descendants = [];
    var stack = [nodeId];
    console.log(edges)
    while (stack.length > 0) {
        console.log("Stack: " + stack);
        var currentId = Number(stack.pop());
        descendants.push(currentId);
        edges.forEach(function (edge) {
            if (edge.from === currentId && !descendants.includes(edge.to)) {
                stack.push(edge.to);
            }
        });
    }
    console.log("Descendants: " + descendants);
    return descendants;
}

// Update the visualizeTree function to optionally filter for a subtree
function visualizeTree(subtreeRootId) {
  var nodes = fullTreeData.nodes;
  var edges = fullTreeData.edges;
  var min_weight = Number.POSITIVE_INFINITY;
  var max_weight = 0;

  // If a subtreeRootId is provided, filter nodes and edges to only those in the subtree
  if (subtreeRootId) {
    console.log("Filtering for subtree with root ID: " + subtreeRootId, edges);
    var descendants = getDescendants(subtreeRootId, edges);
    nodes = nodes.filter((node) => descendants.includes(Number(node.id)));
    edges = edges.filter(
      (edge) =>
        descendants.includes(edge.to) || descendants.includes(edge.from),
    );
    console.log("Filtered nodes: ", nodes, "Filtered edges: ", edges);
  }

  // Update vis.js data
  data.nodes.clear();
  data.edges.clear();
  data.nodes.add(nodes);
  data.edges.add(edges);
}

// Event listener for click events to display subtrees
network.on("click", function (params) {
  if (params.nodes.length === 1) {
    var nodeId = params.nodes[0];
    console.log("Node clicked: " + nodeId);
    var nodeId = params.nodes[0];
    visualizeTree(nodeId);
  }
});

// Event listener for right-click events to return to the full tree
network.on("oncontext", function (params) {
  params.event.preventDefault();
  console.log("Right-click detected. Returning to full tree view.");
  visualizeTree(); // Pass the full tree data to restore the full view
});

document
  .getElementById("fileInput")
  .addEventListener("change", function (event) {
    var input = event.target;

    if ("files" in input && input.files.length > 0) {
      var reader = new FileReader();
      reader.onload = function () {
        var json = JSON.parse(reader.result);
    console.log("File loaded, processing JSON data...");
        processJsonData(json); // Process the JSON data
        visualizeTree(); // Visualize the full tree
    console.log("Visualizing tree...");
      };
      reader.readAsText(input.files[0]);
    }
  });

// Event listener for dragover to allow for the drop action
document.body.addEventListener("dragover", function (e) {
  e.preventDefault();
});

// Event listener for drop to handle the file data
document.body.addEventListener("drop", function (e) {
  e.preventDefault();
  var files = e.dataTransfer.files;
  if (files.length > 0) {
    var file = files[0];
    var reader = new FileReader();
    reader.onload = function () {
      var json = JSON.parse(reader.result);
    console.log("File dropped, processing JSON data...");
      processJsonData(json); // Process the JSON data
    console.log("Visualizing tree...");
      visualizeTree(); // Visualize the full tree
    };
    reader.readAsText(file);
  }
});
// Define the scale_edge_width function in JavaScript
function scale_edge_width(
  cumulative_weight,
  max_weight,
  min_weight,
  log_base,
  max_thickness = 33,
  min_thickness = 1,
) {
  // Ensure the cumulative_weight is not less than min_weight to avoid log(0)
  cumulative_weight = Math.max(cumulative_weight, min_weight);

  // Apply logarithmic scaling
  var log_weight =
    Math.log(cumulative_weight) / Math.log(log_base) -
    Math.log(min_weight) / Math.log(log_base);
  var log_max =
    Math.log(max_weight) / Math.log(log_base) -
    Math.log(min_weight) / Math.log(log_base);

  // Amplify the difference after logarithmic scaling
  var amplified_weight = Math.pow(log_weight / log_max, 2.5); // Raising to a power to amplify differences

  // Scale the amplified_weight to the range of thicknesses
  var scaled_weight =
    amplified_weight * (max_thickness - min_thickness) + min_thickness;

  return scaled_weight;
}
</script>

</body>
</html>

