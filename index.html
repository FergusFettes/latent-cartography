<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Visualizer</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden; /* Disable scrollbars */
        height: 100%; /* Full height */
        width: 100%; /* Full width */
    }
    #mynetwork {
        height: 100%;
        width: 100%;
        position: absolute; /* Positioned relative to the viewport */
        top: 0;
        left: 0;
    }
.search-results-popup {
    display: none;
    position: absolute;
    top: 50px;
    right: 10px;
    border: 1px solid #ccc;
    background: #fff;
    z-index: 10;
    padding: 10px;
    max-height: 300px;
    overflow-y: auto;
    width: 200px;
}
</style>
</head>
<body>

<script>
// Load JSON data from local storage if available
document.addEventListener('DOMContentLoaded', function() {
    var storedJson = localStorage.getItem('treeData');
    if (storedJson) {
        var json = JSON.parse(storedJson);
        processJsonData(json);
        visualizeTree();
    }
});
</script>
<div style="position: absolute; top: 10px; right: 10px; z-index: 5;">
    <button id="clearButton">Clear</button>
<input type="text" id="searchInput" placeholder="Search nodes...">
<button id="searchButton">Search</button>
</div>
<div id="searchResultsPopup" class="search-results-popup"></div>
<div id="mynetwork"></div>

<script>
// Create a network
var container = document.getElementById("mynetwork");
var data = {
  nodes: new vis.DataSet([]),
  edges: new vis.DataSet([]),
};
var options = {
  layout: {
    hierarchical: {
      direction: "LR", // Left to Right
      sortMethod: "directed", // Directed layout to respect the direction of edges
      levelSeparation: 50,
      nodeSpacing: 30,
    },
  },
  physics: {
    enabled: false, // Disable physics for hierarchical layout
  },
};
var network = new vis.Network(container, data, options);
// Store the full tree data globally
var fullTreeData = { nodes: [], edges: [] };
// Function to process JSON and store it in fullTreeData
function processJsonData(json) {
    var nodes = [];
    var edges = [];
    for (var key in json) {
        if (json.hasOwnProperty(key)) {
            var node = json[key];
            var numericKey = Number(key);
            nodes.push({ id: numericKey, label: node.word, shape: "box", probability: node.prob });

            if (node.parent !== null) {
                edges.push({ from: Number(node.parent), to: numericKey });
            }
        }
    }
    fullTreeData = { nodes: nodes, edges: edges };
}
    console.log("JSON data processed", fullTreeData);

function getDescendants(nodeId, edges) {
    var descendants = [];
    var stack = [nodeId];
    console.log(edges)
    while (stack.length > 0) {
        console.log("Stack: " + stack);
        var currentId = Number(stack.pop());
        descendants.push(currentId);
        edges.forEach(function (edge) {
            if (edge.from === currentId && !descendants.includes(edge.to)) {
                stack.push(edge.to);
            }
        });
    }
    console.log("Descendants: " + descendants);
    return descendants;
}

// Update the visualizeTree function to optionally filter for a subtree and scale edge widths
function visualizeTree(subtreeRootId) {
  var nodes = fullTreeData.nodes;
  var edges = fullTreeData.edges;

  // If a subtreeRootId is provided, filter nodes and edges to only those in the subtree
  if (subtreeRootId) {
    var descendants = getDescendants(subtreeRootId, edges);
    console.log("Filtering for subtree with root ID: " + subtreeRootId, edges);
    nodes = nodes.filter((node) => descendants.includes(Number(node.id)));
    edges = edges.filter(
      (edge) =>
        descendants.includes(edge.to) || descendants.includes(edge.from),
    );
    console.log("Filtered nodes: ", nodes, "Filtered edges: ", edges);
  }

  // Calculate min and max weights for scaling after filtering
  var min_weight = Number.POSITIVE_INFINITY;
  var max_weight = 0;

  nodes.forEach(function (node) {
    if (node.probability < min_weight) {
      min_weight = node.probability;
    }
    if (node.probability > max_weight) {
      max_weight = node.probability;
    }
  });

  // Scale edge widths based on node probabilities
  edges = edges.map(function (edge) {
    return {
      from: edge.from,
      to: edge.to,
      value: scale_edge_width(
        nodes.find((node) => node.id === edge.to).probability,
        max_weight,
        min_weight,
        10 // Log base
      ),
    };
  });

  // Update vis.js data
  data.nodes.clear();
  data.edges.clear();
  data.nodes.add(nodes);
  data.edges.add(edges);

  // If a subtreeRootId is provided, recenter the view on the subtree
  if (subtreeRootId) {
    var subtreeRoot = nodes.find((node) => node.id === subtreeRootId);
    network.focus(subtreeRootId, { scale: 1 });
  }

}

// Event listener for click events to display subtrees
network.on("click", function (params) {
  if (params.nodes.length === 1) {
    var nodeId = params.nodes[0];
    console.log("Node clicked: " + nodeId);
    var nodeId = params.nodes[0];
    visualizeTree(nodeId);
  }
});

// Event listener for right-click events to return to the full tree
network.on("oncontext", function (params) {
  params.event.preventDefault();
  console.log("Right-click detected. Returning to full tree view.");
  visualizeTree(); // Pass the full tree data to restore the full view
});

// Event listener for dragover to allow for the drop action
document.body.addEventListener("dragover", function (e) {
  e.preventDefault();
});

// Event listener for drop to handle the file data
document.body.addEventListener("drop", function (e) {
  e.preventDefault();
  var files = e.dataTransfer.files;
  if (files.length > 0) {
    var file = files[0];
    var reader = new FileReader();
    reader.onload = function () {
      var json = JSON.parse(reader.result);
    console.log("File dropped, processing JSON data...");
      processJsonData(json); // Process the JSON data
    console.log("Visualizing tree...");
      visualizeTree(); // Visualize the full tree
localStorage.setItem('treeData', JSON.stringify(json));
    };
    reader.readAsText(file);
  }
});

// Define the scale_edge_width function in JavaScript
function scale_edge_width(
  cumulative_weight,
  max_weight,
  min_weight,
  log_base,
  max_thickness = 33,
  min_thickness = 1,
) {
  // Ensure the cumulative_weight is not less than min_weight to avoid log(0)
  cumulative_weight = Math.max(cumulative_weight, min_weight);

  // Apply logarithmic scaling
  var log_weight =
    Math.log(cumulative_weight) / Math.log(log_base) -
    Math.log(min_weight) / Math.log(log_base);
  var log_max =
    Math.log(max_weight) / Math.log(log_base) -
    Math.log(min_weight) / Math.log(log_base);

  // Amplify the difference after logarithmic scaling
  var amplified_weight = Math.pow(log_weight / log_max, 2.5); // Raising to a power to amplify differences

  // Scale the amplified_weight to the range of thicknesses
  var scaled_weight =
    amplified_weight * (max_thickness - min_thickness) + min_thickness;

  return scaled_weight;
}
// Simple fuzzy search function to match node labels
// Enhanced fuzzy search function to match node labels and count descendants
function fuzzySearch(query, nodes, edges) {
    var results = [];
    var queryLower = query.toLowerCase();
    nodes.forEach(function(node) {
        if (node.label.toLowerCase().includes(queryLower)) {
            var descendantsCount = getDescendants(node.id, edges).length - 1; // Exclude the node itself
            results.push({ node: node, count: descendantsCount });
        }
    });
    return results;
}

// Event listener for the search button
// Event listener for the search input to perform live search
// Event listener for the search input to perform live search and show the number of matches
document.getElementById('searchInput').addEventListener('input', function() {
    var query = document.getElementById('searchInput').value;
    var searchResultsPopup = document.getElementById('searchResultsPopup');
    if (query) {
        var searchResults = fuzzySearch(query, fullTreeData.nodes, fullTreeData.edges);
        if (searchResults.length > 0) {
            var resultsHTML = searchResults.map(function(result) {
                return '<div class="search-result-item" data-node-id="' + result.node.id + '">' +
                    result.node.label + ' (' + result.count + ' matches)</div>';
            }).join('');
            searchResultsPopup.innerHTML = resultsHTML;
            searchResultsPopup.style.display = 'block';
            console.log("Search results: ", searchResults);
        } else {
            searchResultsPopup.innerHTML = 'No matching nodes found.';
            console.log("No matching nodes found.");
        }
    } else {
        searchResultsPopup.style.display = 'none';
    }
});

// Event listener for clicking on search result items
document.addEventListener('click', function(event) {
    if (event.target.classList.contains('search-result-item')) {
        var nodeId = event.target.getAttribute('data-node-id');
        network.focus(nodeId, { scale: 1 });
        document.getElementById('searchResultsPopup').style.display = 'none';
    }
});
// Event listener for the search input to handle Enter keypress
document.getElementById('searchInput').addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
        var searchResultsPopup = document.getElementById('searchResultsPopup');
        var firstResultItem = searchResultsPopup.querySelector('.search-result-item');
        if (firstResultItem) {
            var nodeId = firstResultItem.getAttribute('data-node-id');
            network.focus(nodeId, { scale: 1 });
            searchResultsPopup.style.display = 'none';
        }
    }
});

// Event listener for the 'Clear' button
document.getElementById('clearButton').addEventListener('click', function() {
    localStorage.removeItem('treeData'); // Clear local storage
    location.reload(); // Reload the page to reset the visualization
});
</script>
</body>
</html>

